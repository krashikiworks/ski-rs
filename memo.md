# SKI Combinator Login in Rust

## まえがき

SKIコンビネータをRustで作りたい。
しかもそれをUmlambda記法でやりたい。

## 目標

目指すのはこう

    $cargo run -- ```s``kii```skiis
    `ss

## 目標分析

これを見てみると、ski(仮称)は、
文字列 -> 文字列の処理系であることが分かる。
てことは必要なのは、

* SKIコンビネータ論理計算を表現する抽象機械
* 文字列->抽象機械のフロントエンド
* 抽象機械->文字列のバックエンド

の3つである(多分…)

## 抽象機械0 SKIコンビネータ論理計算

そもそもSKIコンビネータ論理とは

    S: ^xyz.xz(y(z))
    K: ^xy.x
    I: ^x.x

という型無しラムダ計算式で定義される3つのコンビネータの組み合わせによって全ての計算可能関数が定義できる(=チューリング完全)というものだ。
定式的な定義やチューリング完全の話はここでやりたくないのでWikipediaでも参照されたし。
本来は

    S(KII)(SKII)S => SS

と言う風に書くのが自然だが、Unlambdaというプログラミング言語で採用されている記法では

    ```s``kii```skiis => `ss

という形で表記する。「`」が1変数関数への関数適用を意味する……要するに関数型言語で言う所のカリー化と部分適用の組み合わせによって括弧を無くしている。
(そもそも多変数ラムダ関数式はネストした1変数ラムダ関数式の糖衣構文である)
この記法の優れている所は、有効な式は全て1変数関数の組み合わせ(と適用)と見て取れるので、式全体を二分木という非常に簡素な構造で表現することができるという点にある。

今回はこれをRustで実装することを目標にする。

## 抽象機械1 自爆的吶喊

じゃあまずは抽象機械から作ってみる。
SKIコンビネータはそれぞれラムダ式で定義されるので、そのままRustの匿名関数――クロージャに書き下してみたい。

    type S = |x| move |y| move |z| x(z)(y(z));
    type K = |x| move |y| z;
    type I = |x| x;

これはコンパイルできない。なぜかというとRustではクロージャは型ではないからだ。
なので値としてやってみよう。

    static S = |x| move |y| move |z| x(z)(y(z));
    static K = |x| move |y| z;
    static I = |x| x;

これもダメ。なぜならRustはグローバル変数を宣言する時は型名を明示的に表現しなくてはいけないから。
ならばコンビネータの型名を……と言いたいところだが、ここで問題が発生した。

コンビネータの型ってなんだ?

## 抽象機械2 SKIコンビネータと型

Rustは強い型付け言語である。
と言う事は、RustでSKIコンビネータを実装する場合、それを構成する全ての構造の型を明確にしないといけないということだ。
SKIコンビネータの型とはどんなものだろうか?

まず、今回作るskiで有効な入力は{「`」, 「s」, 「k」, 「i」}の4種類の文字である。
「`」は関数適用に、その他の3文字がそれぞれコンビネータに対応している。
関数適用はコンビネータへの操作なので除外できるとして、その他の3つ、つまりS・K・Iという3つのコンビネータの型を考えないといけない。

### Iの型

簡単そうなI: ^x.xから。
これは簡単で、任意の型の値を受け取ってその値と同じ型(そして同じ値)を返すという関数である。

### Kの型

K: ^xy.xは任意の2つの型の値を受け取って前者の型(と値)を返す関数だ。

### Sの型

S: ^xyz.xz(y(z)) は……Sは何だ?
Sは任意の3つの型と値を取る。そして……xz(y(z))の型の値を返す。xz(y(z))って何だ?

少なくとも返り値のxz(y(z))もSKIコンビネータ(の引数)として有効でないといけないはずだ。
ということは?

### SKIコンビネータ全体の型

S・K・Iそれぞれのコンビネータは、それぞれS・K・Iとそれらの組み合わせしか引数として受け取らない。
ということは、これら全体をSKIコンビネータとしてまとめて1つの型として表現することができるはずだ。
Rustの代数的データ型でいうとこんな感じだ:

    enum SkiCombinator {
        S,
        K,
        I,
        Combi
    }

そうなると、

* Iは(SkiCombinator -> SkiCombinator)な関数という型
* Kは(SkiCombinator, SkiCombinator -> SkiCombinator)な関数という型
* Sは(SkiCombinator, SkiCombinator, SkiCombinator -> SkiCombinator)な関数という型

そして、

* CombiはS・K・Iの複合型
* SkiCombinatorはS・K・I・Combiの総称としての型

ということになるはずだ。

## 項書き換え系

SKIコンビネータ計算は項書き換え系として見ることができる。つまり計算式を抽象構文木として、計算を構文木の変形と解釈することができる。

ここで、有効なUnlambdaスタイルSKIコンビネータ式とは

    s, k, i は有効な式である
    x, y が有効な式の場合、 `xy も有効な式である
    以上より有効な式のみが有効なUnlambdaスタイルSKIコンビネータ式である

ざっくりしているがこんな感じ。

内部的に、つまりSKIコンビネータとして有効な値とは

    S, K, I は有効な値である
    X が有効な値の場合、 S(X), K(X) も有効な値である
    X, Y が有効な値の場合、 S(X, Y) も有効な値である

さらに、XとYが外延的に等しいことを

    X = Y

と表記するなら、式と値には

    X が有効な値の場合、`SX = S(X), `KX = K(X)
    X, Y が有効な値の場合 `S(X)Y = S(X, Y), `K(X)Y = X
    X, Y, Zが有効な値の場合 `S(X, Y)Z = ``XZ`YZ

という関係がある。(式と値をごっちゃに混ぜているので後で見直したい)

これを踏まえて抽象構文木Astの設計は

* 1つの有効なUnlambdaスタイルSKIコンビネータ式は1つのAstに1対1対応する
　* Astにも有効無効がある?
